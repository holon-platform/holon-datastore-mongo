[[MongoDatastore]]
== MongoDB Datastore

The link:https://www.mongodb.com[MongoDB^] Datastore API is available in three implementations:

* A *synchronous* implementation, which is the reference implementation of the Holon Platform link:{coreapidir}/com/holonplatform/core/datastore/Datastore.html[Datastore^] API: See <<SyncMongoDatastore>>.

* An *asynchronous* implementation, which is the reference implementation of the Holon Platform link:{coreapidir}/com/holonplatform/async/datastore/AsyncDatastore.html[AsyncDatastore^] API: See <<AsyncMongoDatastore>>.

* An *reactive* implementation, which is the reference implementation of the Holon Platform link:{reactorapidir}/com/holonplatform/reactor/datastore/ReactiveDatastore.html[ReactiveDatastore^] API: See <<ReactiveMongoDatastore>>.

[[MongoDBDatastoreConfiguration]]
=== MongoDB Datastore configuration

Regardless of the actual implementation, each MongoDB Datastore provides a set of configuration options, described below.

==== Database name

A MongoDB Datastore is *always bound to a single MongoDB database*, so the the database name configuration is required to build a MongoDB Datastore instance.

Each builder provides a `database(String database)` method to set the *database name* to which the MongoDB Datastore is bound.

Example:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=dbname,indent=0]
----
<1> Obtain a builder to configure and create a new MongoDB Datastore (in this example, a synchronous `MongoDatastore` implementation)
<2> Set the MongoDB client to use
<3> Set the database name to use

==== Common MongoDB Datastore configuration options

A set of common configuration options are available from the MongoDB Datastore builder, regardless of the actual implementation used.

These common configuration options allows to:

* Configure the default *read preference* to use.
* Configure the default *read concern* to use.
* Configure the default *write concern* to use.
* Add a new bson `Codec`.
* Add a new bson `CodecProvider`.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=config1,indent=0]
----
<1> Set the default read preference
<2> Set the default read concern
<3> Set the default write concern
<4> Add a new bson `Codec`
<5> Add a new bson `CodecProvider`

[[EnumCodecStrategy]]
==== `Enum` codec strategy

By default, *enumeration* type document field values are mapped to a Java `Enum` class using a *name based* matching strategy.

An *ordinal based* matching strategy is also available, using the `Enum` ordinal position to map an enumeration type document field value to a Java `Enum` class.

The enumeration codec strategies are listed in the link:{apidir}/com/holonplatform/datastore/mongo/core/document/EnumCodecStrategy.html[EnumCodecStrategy^] enumeration and the strategy to use can be configured using the MongoDB Datastore builder `enumCodecStrategy` method.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=config2,indent=0]
----
<1> Set the enumeration codec strategy to `ORDINAL`

==== Common Datastore API configuration options

Every MongoDB Datastore builder, regardless of the actual implementation, extends the core Datastore builder API, which provides the common Datastore configuration settings listed below.

|===
|Builder method |Arguments |Description

|`dataContextId`
|The _data context id_ `String` value
|Set the _data context id_ to which the Datastore is bound. Can be used, for example, to declare configuration properties for multiple Datastore instances.

|`traceEnabled`
|`true` or `false`
|Whether to enable Datastore operations _tracing_. When enabled, the MongoDB Datastore will log the JSON representation of the documents involved in the performed datastore operations.

|`configuration`
|A `DatastoreConfigProperties` instance
|Set the `DatastoreConfigProperties` type configuration property set instance to use in order to read the Datastore configuration properties. See the link:holon-core.html#DatastoreConfiguration[Datastore configuration^] documentation section for details. This configuration properties can be used as an alternative for the programmatic configuration performed with the previous builder methods. 
|===

Example:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=config3,indent=0]
----
<1> Set a _data context id_ for the Datastore
<2> Activate operations _tracing_ in log

The configuration properties can also be provided through an external configuration property source, using the properties provided by the link:{coreapidir}/com/holonplatform/core/datastore/DatastoreConfigProperties.html[DatastoreConfigProperties^] property set.

For example, supposing to have a properties file named `datastore.properties` like this:

[source, text]
----
holon.datastore.trace=true
----

We can use it as configuration property source to enable the Datastore _tracing_ mode:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=config4,indent=0]
----
<1> Use the `datastore.properties` file as configuration property source

[[DocumentsMapping]]
=== Property model and MongoDB documents mapping

The Holon Platform link:holon-core.html#PropertyBox[PropertyBox^] type, used by the `Datastore` API to collect and handle the data model attributes values using the link:holon-core.html#Property[Property^] model, is mapped into a MongoDB *BSON Document* using the following conventions:

* Each `PropertyBox` instance is mapped into a MongoDB BSON _document_, using the *property set* bound to the `PropertyBox` instance to determine the available document nodes *names*.
* Each *property name* is mapped to a document *node name*. By default only the `Path` type properties are used for mapping, using the *path name* as node name.
* Each *property value* available from the `PropertyBox` instance is mapped into a document *node value*, performing suitable data type convesions if required.

==== Nested documents

Nested MongoDB documents can be represented using either:

*1. Nested property names using a dot notation:*

When _nested path_ names are included in the property set, either using the dot notation or _parent_ path declarations, they will be mapped as *nested document* properties in the MongoDB BSON Document.

For example:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMapping.java[tag=mapping1,indent=0]
----

The `SUBJECT` property set will be mapped into a _Document_ with:

* A `name` String type node at root level.
* A nested `address` document with the `street` and `city` String type nodes.

*2. Nested `PropertyBox` type properties:*

A `PropertyBox` type property can be used to represent a nested document. The nested document nodes will be the one represented by the *property set* bound to `PropertyBox` type property.

For this purpose, the link:{coreapidir}/com/holonplatform/core/property/PropertyBoxProperty.html[PropertyBoxProperty^] type can be used, which makes available a builder to create a new `PropertyBox` type property providing the *property set* to use.

For example:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMapping.java[tag=mapping2,indent=0]
----

The `SUBJECT` property set will be mapped into a _Document_ with the same schema of the previous example, i.e.:

* A `name` String type node at root level.
* A nested `address` document with the `street` and `city` String type nodes.

==== Multi value document nodes

Multi value (array) MongoDB Document nodes can be represented using a `Collection` type property. 

The standard link:{coreapidir}/com/holonplatform/core/property/SetPathProperty.html[SetPathProperty^] and link:{coreapidir}/com/holonplatform/core/property/ListPathProperty.html[ListPathProperty^] types can be used to represent a `Set` or `List` type collection of values.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMapping.java[tag=mapping3,indent=0]
----
<1> Will be mapped into an array type Document node value and represented as a Java `List`
<2> Will be mapped into an array type Document node value and represented as a Java `Set`

[[DocumentId]]
=== Document id

The MongoDB Datastore supports three data types to represent a *Document id* and to map it to a property:

*1:* The standard `org.bson.types.ObjectId` BSON type:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMapping.java[tag=mapping4,indent=0]
----

*2:* The `String` type:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMapping.java[tag=mapping5,indent=0]
----

*1:* The `BigInteger` type:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMapping.java[tag=mapping6,indent=0]
----

The MongoDB Datastore will perform all the suitable conversions, if required, during the document mapping into and from a `PropertyBox` type.

Regarding the *document id naming strategy*, the following options can be used:

*1:* If a _single_ property is declared as property set identifier and its type is one of the valid document id types (see before), it is used as document id. In this scenario, the property name is irrelevant and *any path name can be used*.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMapping.java[tag=mapping7,indent=0]
----
<1> The `my_document_id` named property will be used as document id, because it is explicitly declared as property set _identifier_

*2:* Otherwise, if a property with the default `_id` name is available in the propert set and its type is one of the valid document id types (see before), that property is used as document id.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMapping.java[tag=mapping8,indent=0]
----
<1> The `_id` String type property will be used as document id, because it is named with the default `_id` name and its type is a valid document id type

NOTE: When a document id property name different form the standard `_id` is used, the MongoDB Datastore _save_, _insert_ and _update_ operations will always include a `_id` document attribute anyway and its value will be synchonized with the property value declared as document id.

[[DatabaseCollections]]
=== Database collections

For each Datastore operation, the target database *collection name* must be specified using the `DataTarget` representation, providing the collection name as data target name.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=target,indent=0]
----
<1> Declare a `DataTarget` for the `my_collection` database collection name

[[AutoGeneratedIds]]
=== Auto-generated ids

The MongoDB Datastore API supports the retrieving of the auto-generated document id values.

The auto-generated document id values can be obtained from the `OperationResult` object, returned by the Datastore data manipulation operations, through the `getInsertedKeys()` and related methods.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=ids1,indent=0]
----
<1> Perform a _insert_ operation using the `Datastore` API
<2> Get the document id value using the `ID` property, if available
<4> Get the first auto-generated document id value

The default *BRING_BACK_GENERATED_IDS* `WriteOption` can be provided to the `Datastore` API operation to bring back any auto-generated document id value into the `PropertyBox` instance which was the subject of the operation.

The auto-generated document id value will be setted in the `PropertyBox` instance using the property which acts as property set identifier. See <<DocumentId>>.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=ids2,indent=0]
----
<1> Document id property declaration using the standard `_id` name
<2> Create the `PropertyBox` value to insert
<3> Perform the _insert_ operation, providing the *BRING_BACK_GENERATED_IDS* write option
<4> The `ID` property value of the inserted `PropertyBox` is updated with the auto-generated document id value

[[SyncMongoDatastore]]
=== Synchronous MongoDB Datastore

The `holon-datastore-mongo-sync` artifact provides the *synchronous* MongoDB `Datastore` API implementation.

_Maven coordinates_:
[source, xml, subs="attributes+"]
----
<groupId>com.holon-platform.mongo</groupId>
<artifactId>holon-datastore-mongo-sync</artifactId>
<version>{revnumber}</version>
----

The link:{apidir}/com/holonplatform/datastore/mongo/sync/MongoDatastore.html[MongoDatastore^] interface represents the synchronous MongoDB Datastore API implementation, extending the link:{coreapidir}/com/holonplatform/core/datastore/Datastore.html[Datastore^] API.

NOTE: A synchronous link:https://mongodb.github.io/mongo-java-driver[MongoDB Java driver^] is required in classpath in order for the datastore to work.

The `MongoDatastore` API, besides the standard `Datastore` API operations, provides a `builder()` method which can be used to create and configure a `MongoDatastore` API istance.

A `com.mongodb.client.MongoClient` reference is required for the `MongoDatastore` instance setup.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleSyncMongoDatastore.java[tag=builder1,indent=0]
----
<1> Obtain a builder to configure and create a new `MongoDatastore` instance
<2> Set the MongoDB client to use

IMPORTANT: If you want to reach the goal of a *_complete abstraction_* from the persistence store technology and the persistence model, the core `Datastore` API interface should be used instead of the specific `MongoDatastore` API by your application code. This way, the concrete `Datastore` API implementation may be replaced by a different one at any time, without any change to the codebase.

To reach the goal of a complete abstraction from the persistence store technology and the persistence model, the core `Datastore` API interface should be used by your application code, instead of the specific `MongoDatastore` API:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleSyncMongoDatastore.java[tag=builder2,indent=0]
----
<1> Obtain a builder to configure and create a new `MongoDatastore` instance and expose it as a  `Datastore` API type 
<2> Set the MongoDB client to use

For example, given the following property model declaration:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleModel.java[tag=model,indent=0]
----
<1> Document id property using the standard `_id` name and `String` as value type
<2> A `String` type document property declation which maps the `name` document attribute
<3> Property set declaration including the `ID` and `NAME` properties. The `ID` property is explicitly declared as the identifier property, even if in this case it would not have been necessary because the `ID` property is mapped to the standard `_id` document id attribute name.
<4> Data target declation using the `my_collection` database collection name

Below an example of some datastore operations using the _synchronous_ MongoDB Datastore API:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleSyncMongoDatastore.java[tag=ops,indent=0]
----
<1> Build a MongoDB `Datastore` bound to the `test` database name
<2> Save (insert if not present or update otherwise) given `PropertyBox` value in the `my_collection` database collection name (using the `TARGET` declaration)
<3> Get the auto-generated document id value, mapped to the `ID` property declaration
<4> Insert given value using the `BRING_BACK_GENERATED_IDS` default write option
<5> The auto-generated document id value will be setted in the provided `PropertyBox` value, bound to the `ID` property
<6> Update given value
<7> Delete the value
<8> Perform a _count_ query on the `my_collection` database collection, providing some filters
<9> Perform a query on the `my_collection` database collection, providing a filter and a sort declaration and projecting the query results as a stream of `PropertyBox` values
<10> Perform a query to obtain a single value of the `ID` property, if available
<11> Perform a _bulk_ update
<12> Perform a _bulk_ delete

[[AsyncMongoDatastore]]
=== Asynchronous MongoDB Datastore

The `holon-datastore-mongo-async` artifact provides the *asynchronous* MongoDB `AsyncDatastore` API implementation.

_Maven coordinates_:
[source, xml, subs="attributes+"]
----
<groupId>com.holon-platform.mongo</groupId>
<artifactId>holon-datastore-mongo-async</artifactId>
<version>{revnumber}</version>
----

The link:{apidir}/com/holonplatform/datastore/mongo/async/AsyncMongoDatastore.html[AsyncMongoDatastore^] interface represents the asynchronous MongoDB Datastore API implementation, extending the link:{coreapidir}/com/holonplatform/async/datastore/AsyncDatastore.html[AsyncDatastore^] API.

NOTE: An asynchronous link:https://mongodb.github.io/mongo-java-driver[MongoDB Java driver^] is required in classpath in order for the datastore to work.

The `AsyncMongoDatastore` API, besides the standard `AsyncDatastore` API operations, provides a `builder()` method which can be used to create and configure an `AsyncMongoDatastore` API istance.

A `com.mongodb.reactivestreams.client.MongoClient` reference is required for the `AsyncMongoDatastore` instance setup.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleAsyncMongoDatastore.java[tag=builder1,indent=0]
----
<1> Obtain a builder to configure and create a new `AsyncMongoDatastore` instance
<2> Set the MongoDB client to use

IMPORTANT: If you want to reach the goal of a *_complete abstraction_* from the persistence store technology and the persistence model, the `AsyncDatastore` API interface should be used instead of the specific `AsyncMongoDatastore` API by your application code. This way, the concrete `AsyncDatastore` API implementation may be replaced by a different one at any time, without any change to the codebase.

To reach the goal of a complete abstraction from the persistence store technology and the persistence model, the `AsyncDatastore` API interface should be used by your application code, instead of the specific `AsyncMongoDatastore` API:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleAsyncMongoDatastore.java[tag=builder2,indent=0]
----
<1> Obtain a builder to configure and create a new `AsyncMongoDatastore` instance and expose it as a  `AsyncDatastore` API type 
<2> Set the MongoDB client to use

The `AsyncDatastore` API uses the `java.util.concurrent.CompletionStage` interface to provide the asynchronous operation results.

Below an example of some datastore operations using the _asynchronous_ MongoDB Datastore API:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleAsyncMongoDatastore.java[tag=ops,indent=0]
----
<1> Build a MongoDB `AsyncDatastore` bound to the `test` database name
<2> Save (insert if not present or update otherwise) given `PropertyBox` value in the `my_collection` database collection name (using the `TARGET` declaration)
<3> Get the auto-generated document id value, mapped to the `ID` property declaration
<4> Insert given value using the `BRING_BACK_GENERATED_IDS` default write option
<5> The auto-generated document id value will be setted in the provided `PropertyBox` value, bound to the `ID` property
<6> Update given value
<7> Delete the value
<8> Perform a _count_ query on the `my_collection` database collection, providing some filters
<9> Perform a query on the `my_collection` database collection, providing a filter and a sort declaration and projecting the query results as a stream of `PropertyBox` values
<10> Perform a query to obtain a single value of the `ID` property, if available
<11> Perform a _bulk_ update
<12> Perform a _bulk_ delete

[[ReactiveMongoDatastore]]
=== Reactive MongoDB Datastore

The `holon-datastore-mongo-reactor` artifact provides the *reactive* MongoDB `AsyncDatastore` API implementation, using the link:https://projectreactor.io[Project Reactor^] `Mono` and `Flux` to provide and handle the datastore operations results.

_Maven coordinates_:
[source, xml, subs="attributes+"]
----
<groupId>com.holon-platform.mongo</groupId>
<artifactId>holon-datastore-mongo-reactor</artifactId>
<version>{revnumber}</version>
----

The link:{apidir}/com/holonplatform/datastore/mongo/reactor/ReactiveMongoDatastore.html[ReactiveMongoDatastore^] interface represents the asynchronous MongoDB Datastore API implementation, extending the link:{reactorapidir}/com/holonplatform/reactor/datastore/ReactiveDatastore.html[ReactiveDatastore^] API.

NOTE: A reactive link:https://mongodb.github.io/mongo-java-driver[MongoDB Java driver^] is required in classpath in order for the datastore to work.

The `ReactiveMongoDatastore` API, besides the standard `ReactiveDatastore` API operations, provides a `builder()` method which can be used to create and configure a `ReactiveMongoDatastore` API istance.

A `com.mongodb.reactivestreams.client.MongoClient` reference is required for the `ReactiveMongoDatastore` instance setup.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleReactiveMongoDatastore.java[tag=builder1,indent=0]
----
<1> Obtain a builder to configure and create a new `ReactiveMongoDatastore` instance
<2> Set the MongoDB client to use

IMPORTANT: If you want to reach the goal of a *_complete abstraction_* from the persistence store technology and the persistence model, the `ReactiveDatastore` API interface should be used instead of the specific `ReactiveMongoDatastore` API by your application code. This way, the concrete `ReactiveDatastore` API implementation may be replaced by a different one at any time, without any change to the codebase.

To reach the goal of a complete abstraction from the persistence store technology and the persistence model, the `ReactiveDatastore` API interface should be used by your application code, instead of the specific `ReactiveMongoDatastore` API:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleReactiveMongoDatastore.java[tag=builder2,indent=0]
----
<1> Obtain a builder to configure and create a new `ReactiveMongoDatastore` instance and expose it as a  `ReactiveDatastore` API type 
<2> Set the MongoDB client to use

The `ReactiveDatastore` API uses the Project Reactor `reactor.core.publisher.Mono` and `reactor.core.publisher.Flux` objects to provide the operation results.

Below an example of some datastore operations using the _reactive_ MongoDB Datastore API:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleReactiveMongoDatastore.java[tag=ops,indent=0]
----
<1> Build a MongoDB `ReactiveDatastore` bound to the `test` database name
<2> Save (insert if not present or update otherwise) given `PropertyBox` value in the `my_collection` database collection name (using the `TARGET` declaration)
<3> Get the auto-generated document id value, mapped to the `ID` property declaration
<4> Insert given value using the `BRING_BACK_GENERATED_IDS` default write option
<5> The auto-generated document id value will be setted in the provided `PropertyBox` value, bound to the `ID` property
<6> Update given value
<7> Delete the value
<8> Perform a _count_ query on the `my_collection` database collection, providing some filters
<9> Perform a query on the `my_collection` database collection, providing a filter and a sort declaration and projecting the query results as a Flux of `PropertyBox` values
<10> Perform a query to obtain a single value of the `ID` property, if available
<11> Perform a _bulk_ update
<12> Perform a _bulk_ delete

[[CustomFilterSort]]
=== Custom BSON filters and sorts

The MongoDB Datastore APIs support custom *BSON* filters and sorts expressions, i.e. `QueryFilter` and `QuerySort` type expressions for which the *BSON expression* that represents the filtering and sorting conditions is directly provided.

==== BsonFilter

The link:{apidir}/com/holonplatform/datastore/mongo/core/BsonFilter.html[BsonFilter^] interface is a `QueryFilter` implementation to provide the query restrictions using a *BSON expression*, and it can be used just like any other `QueryFilter` implementation in query definitions.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=bsonfilter,indent=0]
----
<1> Use `BsonFilter` to provide a BSON filter expression that matches all documents where the value of the  `my_field` field is an array of the specified size (3)

==== BsonSort

The link:{apidir}/com/holonplatform/datastore/mongo/core/BsonSort.html[BsonSort^] interface is a `QuerySort` implementation to provide the query sort using a *BSON expression*, and it can be used just like any other `QuerySort` implementation in query definitions.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=bsonsort,indent=0]
----
<1>  Use `BsonSort` to provide a BSON sort specification for a descending sort on the `my_field` field

[[Transactions]]
=== Transactions management

The MongoDB Datastore API implementations support *transactions* management, if transaction support is available from the concrete MongoDB database engine.

IMPORTANT: The multi-document ACID transactions support is available since the *version 4.0* of MongoDB platform and the MongoDB Java driver version *3.8 or higher* is required. 

The transactions management operations are made available using:

* The link:{coreapidir}/com/holonplatform/core/datastore/transaction/Transactional.html[Transactional^] API for the *synchronous* MongoDB Datastore implementation.

* The link:{coreapidir}/com/holonplatform/async/datastore/transaction/AsyncTransactional.html[AsyncTransactional^] API for the *asynchronous* MongoDB Datastore implementation.

* The link:{reactorapidir}/com/holonplatform/reactor/datastore/transaction/ReactiveTransactional.html[ReactiveTransactional^] API for the *reactive* MongoDB Datastore implementation.

==== Synchronous transactions management

The `isTransactional()` or `requireTransactional()` methods of the `Datastore` API can be used to obtain the _transactional_ API which can be used for transactions management.

The link:{coreapidir}/com/holonplatform/core/datastore/transaction/Transaction.html[Transaction^] interface is used as transaction representation and provides methods to inspect the transaction status and perform the *commit* and *rollback* operations.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleSyncMongoDatastore.java[tag=transactional,indent=0]
----
<1> Obtain the `Transactional` API to execute one or more Datastore operation within a transaction
<2> Commit the transaction
<3> Obtain the `Transactional` API to execute the Datastore operation within a transaction and return a value
<4> The transaction is configured with the _auto commit_ mode, this way the transaction is automatically committed at the transactional operation end if no error occurred

==== Asynchronous transactions management

The `isTransactional()` or `requireTransactional()` methods of the `AsyncDatastore` API can be used to obtain the _transactional_ API which can be used for transactions management.

The link:{coreapidir}/com/holonplatform/async/datastore/transaction/AsyncTransaction.html[AsyncTransaction^] interface is used as transaction representation and provides methods to inspect the transaction status and perform the *commit* and *rollback* operations.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleAsyncMongoDatastore.java[tag=transactional,indent=0]
----
<1> Obtain the `AsyncTransactional` API to execute one or more Datastore operation within a transaction
<2> Commit the transaction
<3> Obtain the `AsyncTransactional` API to execute the Datastore operation within a transaction and return a value
<4> The transaction is configured with the _auto commit_ mode, this way the transaction is automatically committed at the transactional operation end if no error occurred

==== Reactive transactions management

The `isTransactional()` or `requireTransactional()` methods of the `ReactiveDatastore` API can be used to obtain the _transactional_ API which can be used for transactions management.

The link:{reactorapidir}/com/holonplatform/reactor/datastore/transaction/ReactiveTransaction.html[ReactiveTransaction^] interface is used as transaction representation and provides methods to inspect the transaction status and perform the *commit* and *rollback* operations.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleReactiveMongoDatastore.java[tag=transactional,indent=0]
----
<1> Obtain the `ReactiveTransactional` API to execute one or more Datastore operation within a transaction
<2> Commit the transaction
<3> Obtain the `ReactiveTransactional` API to execute the Datastore operation within a transaction and return a value
<4> The transaction is configured with the _auto commit_ mode, this way the transaction is automatically committed at the transactional operation end if no error occurred

=== Using the `MongoDatabaseHandler` for a direct database access

The link:{apidir}/com/holonplatform/datastore/mongo/core/MongoDatabaseHandler.html[MongoDatabaseHandler^] API can be used obtain a direct reference to the `MongoDatabase` object which represents the Mongo database configured for the current Datastore implementation.

The `MongoDatabase` reference can be used to perform database operations with the MongoDB Java driver directly, using BSON expressions and outside of the standard Datastore API operations.

Each specific MongoDB datastore implementation provides the `MongoDatabaseHandler` support, using a consistent `MongoDatabase` reference type.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastore.java[tag=handler,indent=0]
----
<1> Get the `MongoDatabase` reference and use it to perform some operations

[[MongoDatastoreExtension]]
=== Extending the MongoDB Datastore API

[[MongoExpressionResolvers]]
=== Expression resolvers

The `Datastore` API can be extended using the `ExpressionResolver` API, to add new expression resolution strategies, modify existing ones and to handle new `Expression` types.

NOTE: See the link:holon-core.html#DatastoreExpressionResolverExtension[Datastore API extension] documentation section for details.

==== MongoDB Expression resolvers registration

A new `ExpressionResolver` can be registered in the MongoDB `Datastore` API in two ways:

*1. Using the MongoDB `Datastore` API instance:*

An `ExpressionResolver` can be registered either using the `Datastore` _builder_ API at Datastore configuration time:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastoreExtension.java[tag=expreg1,indent=0]
----
<1> Register a new `ExpressionResolver`

Or using the `Datastore` API itself, which extends the `ExpressionResolverSupport` API:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastoreExtension.java[tag=expreg2,indent=0]
----
<1> Register and new `ExpressionResolver`

NOTE: The same registration options are available for the `AsyncDatastore` and `ReactiveDatastore` API and builders.

*2. Automatic registration using _Java service extensions_:*

The MongoDB Datastore implementatons support `ExpressionResolver` automatic registration using the link:{apidir}/com/holonplatform/datastore/mongo/core/config/MongoDatastoreExpressionResolver.html[MongoDatastoreExpressionResolver^] base type and the default _Java service extensions_ modality.

To automatically register an `ExpressionResolver` this way, a class implementing `MongoDatastoreExpressionResolver` has to be created and its fully qualified name must be specified in a file named `com.holonplatform.datastore.mongo.core.config.MongoDatastoreExpressionResolver`, placed in the `META-INF/services` folder in classpath.

When this registration method is used, the expression resolvers defined this way will be registered for *any MongoDB Datastore API instance*.

==== Specific expression resolvers registration

All the default `Datastore` API operations supports *operation specific* expression resolvers registration, through the `ExpressionResolverSupport` API.

An `ExpressionResolver` registered for a specific `Datastore` API operation execution will be available only for the execution of that operation, and will be ignored by any other `Datastore` API operation.

For example, to register an expression resolver only for a single `Query` execution, the `Query` builder API can be used:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastoreExtension.java[tag=expreg3,indent=0]
----
<1> Register an expression resolver only for the specific `Query` operation definition

==== Expression resolvers priority

According to the standard convention, the `javax.annotation.Priority` annotation can be used on `ExpressionResolver` classes to indicate in what order the expression resolvers bound to the same _type resolution pair_ (i.e. the expression type handled by a resolver and the target expression type into which it will be resolved) must be applied.

The less is the `javax.annotation.Priority` number assigned to a resolver, the higher will be it's priority order.

All the default MongoDB Datastore expression resolvers have the _minimum_ priority order, allowing to override their behavior and resolution strategies with custom expression resolvers with a higher assigned priority order (i.e. a priority number less then `Integer.MAX_VALUE`).

==== Expression validation

The internal MongoDB Datastore _BSON composer engine_ will perform *validation* on any `Expression` instance to resolve and each corresponding resolved `Expression` instance, using the default expression `validate()` method.

So the `validate()` method can be used to implement custom expression validation logic and throw an `InvalidExpressionException` when validation fails.

==== MongoDB Datastore expressions

Besides the standard link:holon-core.html#DatastoreExpressionResolverExtension[Datastore API expressions], such as `DataTarget`, `QueryFilter` and `QuerySort`, which can be used to extend the `Datastore` API with new expression implementations and new resolution strategies, the MongoDB `Datastore` API can be extended using a set of *specific BSON resolution expressions*, used by the internal _BSON composer engine_ to implement the resolution and composition strategy to obtain the BSON expressions and document mappings from the `Datastore` API meta-language expressions.

These expressions are available from the `com.holonplatform.datastore.mongo.core.expression` package of the `holon-datastore-mongo-core` artifact.

The link:{apidir}/com/holonplatform/datastore/mongo/core/expression/BsonExpression.html[BsonExpression^] is the expression which represents a _BSON expression part_, used to compose the actual BSON statement which will be executed using the MongoDB Java driver.

The `BsonExpression` type can be used to directly resolve an abstract `Datastore` API expression into a BSON statement part.

For example, supposing to have a `IdIs` class which represents a `QueryFilter` expression type to represent the expression _"the `_id` column name value is equal to a given ObjectId type value"_:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastoreExtension.java[tag=expres1,indent=0]
----

We want to create an `ExpressionResolver` class to resolve the `IdIs` expression directly into a *BSON epression*, using the `BsonExpression` type. Using the convenience `create` method of the `ExpressionResolver` API, we can do it in the following way:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastoreExtension.java[tag=expres2,indent=0]
----
<1> Expression type to resolve
<2> Target expression type
<3> Expression resolution logic: since we resolve the `IdIs` expression directly into a `BsonExpression` type, the BSON filter representation is provided

After the `ExpressionResolver` is registered in the `Datastore` API, the new `IdIs` expression can be used in the `Datastore` API operations which support the `QueryFilter` expression type just like any other filter expression. For example, in a `Query` expression:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastoreExtension.java[tag=expres3,indent=0]
----
<1> Register the new expression resolver
<2> Use the `IdIs` expression in a query definition

Other expression types are used to represent the elements of a query or a Datastore operation. These expression types often represent an _intermediate_ expression type, between the highest abstract layer (i.e. an expression of the `Datastore` API meta-language) and the final BSON expression representation.

An example is the link:{apidir}/com/holonplatform/datastore/mongo/core/expression/BsonProjection.html[BsonProjection^] to represent a query projection.

==== MongoDB Expression resolution context

The MongoDB Datastore APIs make available an extension of the standard expression `ResolutionContext`, to provide a set of configuration attributes and BSON resolution context specific operations. 

This resolution context extension is represented by the link:{apidir}/com/holonplatform/datastore/mongo/core/context/MongoResolutionContext.html[MongoResolutionContext^] API.

[[CommodityFactories]]
=== Commodity factories

The MongoDB `Datastore` API supports _Datastore commodities_ registration using a suitable commodity factory type, which is specific for each MongoDB datastore implementation:

* For the *synchronous* `Datastore` implementation, the link:{apidir}/com/holonplatform/datastore/mongo/sync/config/SyncMongoDatastoreCommodityFactory.html[SyncMongoDatastoreCommodityFactory^] type.

* For the *asynchronous* `AsyncDatastore` and the *reactive* `ReactiveDatastore` implementation, the link:{apidir}/com/holonplatform/datastore/mongo/sync/config/AsyncMongoDatastoreCommodityFactory.html[AsyncMongoDatastoreCommodityFactory^] type.

NOTE: See the link:holon-core.html#DatastoreCommodities[Datastore commodities definition and registration^] documentation section to learn how the _Datastore commodity_ architecture can be used to provide extensions to the default `Datastore` API.

These commodity factory types provide a specialized link:{apidir}/com/holonplatform/datastore/mongo/core/config/MongoDatastoreCommodityContext.html[MongoDatastoreCommodityContext^] API extension as commodity context, to make available a set of MongoDB specific configuration attributes and references, for example:

* The current database name and reference.
* The current client session, if available.
* The current codec registry.
* The default read preference, read concern and write concern.
* The available _expression resolvers_.

Furthermore, it makes available some API methods to interact with the underlying database, such as the `withDatabase(MongoDatabaseOperation operation)` method.

Example: definition of a commodity which provides a method to create a database collection:

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastoreExtension.java[tag=commodity,indent=0]
----
<1> Datastore commodity API
<2> Commodity implementation
<3> Commodity factory implementation

A Datastore commodity factory class which extends the `SyncMongoDatastoreCommodityFactory` or the  `AsyncMongoDatastoreCommodityFactory` interface can be registered in a MongoDB Datastore in two ways:

*1. Direct registration using the MongoDB Datastore API builder:*

The MongoDB Datastore APIs supports the commodity factory registration using the `withCommodity` builder method.

[source, java]
----
include::{examplesdir}/com/holonplatform/datastore/mongo/examples/ExampleMongoDatastoreExtension.java[tag=factoryreg,indent=0]
----
<1> Register the `MyCommodityFactory` commodity factory in given Datastore implementation

*2. Automatic registration using the  _Java service extensions_:*

To automatically register an commodity factory using the standard _Java service extensions_ based method, a class implementing either `SyncMongoDatastoreCommodityFactory` or `AsyncMongoDatastoreCommodityFactory` has to be created and its qualified full name must be specified in a file named `com.holonplatform.datastore.mongo.sync.config.SyncMongoDatastoreCommodityFactory` or `com.holonplatform.datastore.mongo.async.config.AsyncMongoDatastoreCommodityFactory`,  placed in the `META-INF/services` folder of the classpath.

When this registration method is used, the commodity factories defined this way will be registered for *any MongoDB Datastore API instance*.
